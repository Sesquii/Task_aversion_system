---
description: Alembic migration patterns for database schema evolution
globs: ["backend/database.py", "alembic/**/*.py", "**/migrations/**/*.py"]
alwaysApply: false
---

# Alembic for Schema Evolution

## When to Use Alembic
- ✅ Adding new columns to existing tables
- ✅ Creating new tables for new features
- ✅ Modifying column types (with data migration)
- ❌ Initial CSV→DB migration (use custom script)
- ❌ One-time data transformations (use Python script)

## Alembic Overview
- Alembic tracks database schema changes as you add features
- Use Alembic AFTER initial CSV→DB migration is complete
- Generates migration scripts automatically from model changes
- Provides rollback capability for schema changes

## Workflow Pattern
When adding new columns/fields to models:
1. Update SQLAlchemy model (add new Column)
2. Generate migration: `alembic revision --autogenerate -m "add_new_field"`
3. Review generated migration file (check for unwanted changes)
4. Apply migration: `alembic upgrade head`
5. Test that existing data still works

## Alembic Setup

### Installation
```bash
pip install alembic
```

### Initialization
```bash
alembic init alembic
```

### Configuration (alembic.ini)
```ini
[alembic]
script_location = alembic
sqlalchemy.url = driver://user:pass@localhost/dbname
```

### Environment Setup (alembic/env.py)
```python
from backend.database import Base
target_metadata = Base.metadata
```

## Common Commands
```bash
# Generate migration from model changes
alembic revision --autogenerate -m "description"

# Apply migrations
alembic upgrade head

# Rollback one migration
alembic downgrade -1

# Rollback to specific revision
alembic downgrade <revision_id>

# Show current revision
alembic current

# Show migration history
alembic history
```

## Migration File Structure
```python
"""add_new_field

Revision ID: abc123
Revises: xyz789
Create Date: 2024-01-01 12:00:00
"""
from alembic import op
import sqlalchemy as sa

# revision identifiers
revision = 'abc123'
down_revision = 'xyz789'
branch_labels = None
depends_on = None

def upgrade():
    op.add_column('tasks', sa.Column('new_field', sa.String(), nullable=True))

def downgrade():
    op.drop_column('tasks', 'new_field')
```

## Data Migrations
When changing column types or adding non-nullable columns with defaults:
```python
def upgrade():
    # Add column as nullable first
    op.add_column('tasks', sa.Column('new_field', sa.String(), nullable=True))
    
    # Populate with default value
    op.execute("UPDATE tasks SET new_field = 'default' WHERE new_field IS NULL")
    
    # Make non-nullable
    op.alter_column('tasks', 'new_field', nullable=False)

def downgrade():
    op.drop_column('tasks', 'new_field')
```

## Best Practices
- Always review auto-generated migrations before applying
- Test migrations on development database first
- Keep migrations small and focused (one feature per migration)
- Never edit existing migration files after they've been applied to production
- Use descriptive migration messages: "add_user_email_field" not "update"
