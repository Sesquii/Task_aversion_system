---
description: Analytics module migration patterns, execution score formulas, and skill framework guidelines
globs: ["backend/analytics.py", "ui/analytics_*.py", "docs/execution_module*.md", "docs/analytics_skill_framework.md"]
alwaysApply: false
---

# Analytics Module Migration Rules

## Execution Score Module (v1.0)

### Core Formula Pattern
The execution score uses a **four-factor multiplicative model**:

```python
execution_score = base_score × (1.0 + difficulty_factor) × 
                  (0.5 + speed_factor × 0.5) × 
                  (0.5 + start_speed_factor × 0.5) × 
                  completion_factor
```

**Key Principles:**
- Base score: 50.0 (neutral starting point)
- All factors range 0.0-1.0 (except difficulty_factor which is added to 1.0)
- Final score clamped to 0-100 range
- Multiplicative combination ensures all factors must be high for high scores

### Component Factor Patterns

#### 1. Difficulty Factor (Exponential Decay)
```python
difficulty_factor = 1.0 × (1 - exp(-(w_aversion × aversion + w_load × load) / k))
```
- **Weights:** `w_aversion = 0.7`, `w_load = 0.3`, `k = 50.0`
- **Use for:** Smooth, diminishing returns curves
- **Location:** `Analytics.calculate_difficulty_bonus()` (static method)

#### 2. Speed Factor (Piecewise)
```python
if time_ratio <= 0.5:
    speed_factor = 1.0  # Very fast (2x speed or faster)
elif time_ratio <= 1.0:
    speed_factor = 1.0 - (time_ratio - 0.5) × 1.0  # Linear
else:
    speed_factor = 0.5 × (1.0 / time_ratio)  # Exponential decay
```
- **Use for:** Measuring efficiency relative to estimates
- **Thresholds:** 0.5 (very fast), 1.0 (on-time)

#### 3. Start Speed Factor (Piecewise with Exponential)
```python
if delay <= 5:
    factor = 1.0  # Perfect
elif delay <= 30:
    factor = 1.0 - ((delay - 5) / 25.0) × 0.2  # Linear
elif delay <= 120:
    factor = 0.8 - ((delay - 30) / 90.0) × 0.3  # Linear
else:
    factor = 0.5 × exp(-excess / 240.0)  # Exponential decay
```
- **Use for:** Measuring procrastination resistance
- **Thresholds:** 5 min (perfect), 30 min (good), 120 min (acceptable)

#### 4. Completion Factor (Piecewise)
```python
if completion >= 100:
    factor = 1.0  # Full
elif completion >= 90:
    factor = 0.9 + (completion - 90) / 10.0 × 0.1  # Near-complete
elif completion >= 50:
    factor = 0.5 + (completion - 50) / 40.0 × 0.4  # Partial
else:
    factor = completion / 50.0 × 0.5  # Low
```
- **Use for:** Measuring quality of completion
- **Thresholds:** 100% (full), 90% (near-complete), 50% (partial)

## Data Handling Patterns

### CSV vs Database Format
**Always handle both formats:**

```python
if isinstance(row, pd.Series):
    # CSV format (pandas Series)
    predicted_dict = json.loads(row['predicted_dict']) if isinstance(row['predicted_dict'], str) else row['predicted_dict']
    actual_dict = json.loads(row['actual_dict']) if isinstance(row['actual_dict'], str) else row['actual_dict']
else:
    # Database format (dict)
    predicted = row.get('predicted', {})
    actual = row.get('actual', {})
    predicted_dict = predicted if isinstance(predicted, dict) else {}
    actual_dict = actual if isinstance(actual, dict) else {}
```

### Missing Data Handling
**Always provide neutral defaults:**

```python
# Default to neutral values
difficulty_factor = 0.0  # if aversion is None
speed_factor = 0.5  # if time data missing
start_speed_factor = 0.5  # if timestamp data missing
completion_factor = 1.0  # if completion data missing (assume 100%)
```

### Timestamp Parsing
**Always handle parsing errors gracefully:**

```python
try:
    if isinstance(timestamp, str):
        parsed_time = pd.to_datetime(timestamp)
    else:
        parsed_time = timestamp
    # Calculate time differences
except (ValueError, TypeError, AttributeError) as e:
    # Fallback to neutral value
    factor = 0.5
```

## Formula Design Patterns

### Exponential Decay Pattern
**Use for:** Smooth, diminishing returns curves

```python
value = max_value × (1 - exp(-input / k))
```

**Characteristics:**
- Smooth curve (no abrupt changes)
- Approaches max_value asymptotically
- Early changes have more impact
- Psychologically accurate

### Piecewise Linear Pattern
**Use for:** Different behavior in different regions

```python
if input <= threshold1:
    value = max_value
elif input <= threshold2:
    # Linear interpolation
    value = max_value - ((input - threshold1) / (threshold2 - threshold1)) × (max_value - min_value)
else:
    # Different behavior
    value = ...
```

### Multiplicative Combination Pattern
**Use for:** Requiring all components to be high

```python
result = base × factor1 × factor2 × factor3 × factor4
```

### Additive Boost Pattern
**Use for:** Adding bonus without penalty

```python
result = base × (1.0 + bonus_factor)
```

## Migration Patterns

### Adding New Factors to Execution Score
1. Define the factor calculation function
2. Add factor to `calculate_execution_score()` method
3. Integrate into multiplicative formula
4. Update documentation (`docs/execution_module_v1.0.md`)
5. Add graphic aid script (if visualizable)
6. Update analytics glossary (`ui/analytics_glossary.py`)

### Modifying Existing Factors
1. Document current behavior (version current formula)
2. Design new formula (consider backward compatibility)
3. Implement new formula with feature flag (if needed)
4. Test with existing data
5. Update documentation
6. Update graphic aids

### Extracting Factors for Reuse
**Extract to static method for reuse:**

```python
@staticmethod
def calculate_speed_factor(time_actual, time_estimate):
    """Calculate speed factor (0.0-1.0)."""
    # ... calculation logic
    return speed_factor
```

## Common Pitfalls and Solutions

### Division by Zero
**Problem:**
```python
time_ratio = time_actual / time_estimate  # Fails if time_estimate is 0
```

**Solution:**
```python
if time_estimate > 0 and time_actual > 0:
    time_ratio = time_actual / time_estimate
    # ... calculation
else:
    speed_factor = 0.5  # Neutral default
```

### Missing Timestamp Data
**Problem:**
```python
start_delay = (started_at - initialized_at).total_seconds() / 60.0
# Fails if timestamps are None or invalid
```

**Solution:**
```python
if initialized_at and started_at:
    try:
        # Parse and calculate
        start_delay = calculate_delay(initialized_at, started_at)
    except (ValueError, TypeError, AttributeError):
        start_speed_factor = 0.5  # Neutral default
else:
    start_speed_factor = 0.5  # Neutral default
```

### JSON Parsing Errors
**Problem:**
```python
predicted_dict = json.loads(row['predicted_dict'])  # Fails if invalid JSON
```

**Solution:**
```python
try:
    predicted_dict = json.loads(row['predicted_dict']) if isinstance(row['predicted_dict'], str) else row['predicted_dict']
except (json.JSONDecodeError, TypeError):
    predicted_dict = {}  # Empty dict as fallback
```

### Factor Range Violations
**Problem:**
```python
execution_score = base_score * factor1 * factor2  # May exceed 100
```

**Solution:**
```python
execution_score = base_score * factor1 * factor2
execution_score = max(0.0, min(100.0, execution_score))  # Clamp to range
```

## Best Practices

1. ✅ **Always provide neutral defaults** for missing data (0.5 for factors, 50 for scores)
2. ✅ **Clamp final scores** to expected ranges (0-100)
3. ✅ **Handle both CSV and database formats** in calculation methods
4. ✅ **Use exponential decay** for smooth, psychologically accurate curves
5. ✅ **Document formula versions** when making changes
6. ✅ **Test edge cases** (zero values, missing data, extreme values)
7. ✅ **Use piecewise functions** for different behavior regions
8. ✅ **Make factors reusable** by extracting to static methods
9. ✅ **Update documentation** when formulas change
10. ✅ **Version formulas** when making significant changes

## Versioning

### Execution Module v1.0
- **Status:** Production-Ready
- **Documentation:** `docs/execution_module_v1.0.md`
- **Implementation:** `backend/analytics.py:calculate_execution_score()`
- **Glossary:** `ui/analytics_glossary.py` (execution_score module)

**When modifying formulas:**
- Document current version before changes
- Create new version document if breaking changes
- Update version number in documentation
- Update implementation comments

## Related Documentation

- **Execution Module v1.0:** `docs/execution_module_v1.0.md`
- **Skill Framework:** `docs/analytics_skill_framework.md`
- **Analytics Glossary:** `ui/analytics_glossary.py`
- **Formula Review:** `docs/formula_review_analysis.md`
- **Implementation:** `backend/analytics.py`

## Testing Requirements

### Factor Calculation Tests
- Test edge cases (0, 100, None)
- Test typical cases (50, 75)
- Test missing data handling

### Execution Score Integration Tests
- Test with CSV format (pandas Series)
- Test with database format (dict)
- Test missing data scenarios
- Verify score range (0-100)

### Data Format Compatibility Tests
- Test CSV format parsing
- Test database format handling
- Test JSON parsing errors
- Test timestamp parsing errors
